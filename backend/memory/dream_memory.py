# backend/memory/dream_memory.py

import json
from typing import Any, Dict, List, Optional, TypeVar, TYPE_CHECKING

import asyncpg
import numpy as np
import torch

from backend.memory.base_memory import BaseMemory

if TYPE_CHECKING:
    from backend.core.minds.base_mind import BaseMind

T_DreamMemory = TypeVar('T_DreamMemory', bound='DreamMemory')

class DreamMemory(BaseMemory):
    """Manages the storage and retrieval of dream entries generated by the system."""

    def __init__(self, config: Dict[str, Any], embedding_mind: 'BaseMind'):
        super().__init__(config)
        if embedding_mind is None:
            raise ValueError("DreamMemory requires a valid embedding_mind instance.")
        self.embedding_mind = embedding_mind
        # Use a high dimension for abstract dream vectors
        self.vector_dimension = 2048
        self.logger.info("DreamMemory initialized with vector dimension %d.", self.vector_dimension)

    @classmethod
    async def create(cls: type[T_DreamMemory], config: Dict[str, Any], embedding_mind: 'BaseMind') -> T_DreamMemory:
        instance = cls(config, embedding_mind)
        try:
            instance.pool = instance.db_manager.get_pool()
            instance._initialized = True
        except ConnectionError as e:
            instance.logger.critical("Failed to get database pool for DreamMemory: %s", e, exc_info=True)
            raise
        return instance

    async def _generate_embedding(self, text: str) -> Optional[List[float]]:
        """Generates a vector embedding for dream content."""
        self.logger.debug("Generating dream embedding for content: '%s...'", text[:70])
        try:
            # We assume creative mind process gives a text payload, but its state vector isn't what we want.
            # A dedicated dream embedder would be better, but for now we re-process with the mind itself.
            result = await self.embedding_mind.process({'text': text, 'logical_mind_instance': self.embedding_mind})
            embedding = result.get('state')
            if isinstance(embedding, np.ndarray):
                embedding = embedding.tolist()
            if isinstance(embedding, torch.Tensor):
                embedding = embedding.cpu().tolist()
            
            if embedding and len(embedding) != self.vector_dimension:
                self.logger.warning("Embedding dimension mismatch! Model output %d, expected %d. Adjusting vector.",
                                  len(embedding), self.vector_dimension)
                embedding = (embedding + [0.0] * self.vector_dimension)[:self.vector_dimension]
            return embedding
        except Exception as e:
            self.logger.error("Failed to generate dream embedding. Error: %s", e, exc_info=True)
            return None

    async def add(self, content: str, symbols: List[str], emotions: List[str], coherence_score: float,
                  vividness_score: float, consciousness_depth: float, dream_type: str, 
                  session_id: Optional[str] = None) -> Optional[str]:
        self.logger.info("Adding new dream entry of type '%s'.", dream_type)
        embedding = await self._generate_embedding(content)
        if embedding is None:
            return None
        try:
            symbols_json = json.dumps(symbols)
            emotions_json = json.dumps(emotions)
        except TypeError as e:
            self.logger.error("Dream symbols or emotions are not JSON-serializable. Error: %s", e)
            return None
        query = """INSERT INTO dream_entries (session_id, content, symbols, emotions, coherence_score,
                                       vividness_score, dream_embedding, consciousness_depth, dream_type)
                   VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9) RETURNING id;"""
        try:
            record_id = await self._fetchval(
                query, session_id, content, symbols_json, emotions_json, coherence_score,
                vividness_score, embedding, consciousness_depth, dream_type
            )
            return str(record_id)
        except Exception as e:
            self.logger.error("Database error while adding dream entry. Error: %s", e, exc_info=True)
            return None

    async def get(self, dream_id: str) -> Optional[Dict[str, Any]]:
        record = await self._fetchrow("SELECT * FROM dream_entries WHERE id = $1;", dream_id)
        return self._format_record(record) if record else None

    async def search(self, query_text: Optional[str] = None, symbols: Optional[List[str]] = None,
                     emotions: Optional[List[str]] = None, min_vividness: float = 0.0,
                     limit: int = 10) -> List[Dict[str, Any]]:
        conditions, params, order_by_clause = ["vividness_score >= $1"], [min_vividness], "ORDER BY created_at DESC"
        if query_text:
            query_embedding = await self._generate_embedding(query_text)
            if query_embedding:
                params.append(query_embedding)
                conditions.append(f"1 - (dream_embedding <=> ${len(params)}) > 0.5")
                order_by_clause = f"ORDER BY dream_embedding <=> ${len(params)} ASC"
        if symbols:
            params.append(json.dumps(symbols))
            conditions.append(f"symbols @> ${len(params)}::jsonb")
        if emotions:
            params.append(json.dumps(emotions))
            conditions.append(f"emotions @> ${len(params)}::jsonb")
        query = f"SELECT * FROM dream_entries WHERE {' AND '.join(conditions)} {order_by_clause} LIMIT ${len(params) + 1};"
        params.append(limit)
        try:
            records = await self._fetch(query, *params)
            return [self._format_record(rec) for rec in records]
        except asyncpg.PostgresError as e:
            self.logger.error("Database error during dream search. Error: %s", e, exc_info=True)
            return []

    async def delete(self, dream_id: str) -> bool:
        status = await self._execute("DELETE FROM dream_entries WHERE id = $1;", dream_id)
        return status.endswith('1')

    async def clear(self, session_id: Optional[str] = None) -> None:
        if session_id:
            await self._execute("DELETE FROM dream_entries WHERE session_id = $1;", session_id)
        else:
            await self._execute("TRUNCATE TABLE dream_entries;")

    def _format_record(self, record: asyncpg.Record) -> Dict[str, Any]:
        return { "id": str(record["id"]), "session_id": record["session_id"], "content": record["content"],
            "symbols": json.loads(record["symbols"]) if record["symbols"] else [], "emotions": json.loads(record["emotions"]) if record["emotions"] else [],
            "coherence_score": record["coherence_score"], "vividness_score": record["vividness_score"],
            "consciousness_depth": record["consciousness_depth"], "dream_type": record["dream_type"], "created_at": record["created_at"],
            "similarity": record.get("similarity", None)
        }